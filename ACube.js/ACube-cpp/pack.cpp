
#include "pack.h"

// =========================================================================
// CORNERS' TWISTS
// =========================================================================
   int  Pack_ct::act(int x)
// -------------------------------------------------------------------------
{
  int r = 0;
  // counts number of zeroes on the particular positions
  // 0 .. specified position, 1 .. unspecified position
  if (~x & 1 << A_CR_UFR) r++;
  if (~x & 1 << A_CR_URB) r++;
  if (~x & 1 << A_CR_UBL) r++;
  if (~x & 1 << A_CR_ULF) r++;
  if (~x & 1 << A_CR_DRF) r++;
  if (~x & 1 << A_CR_DFL) r++;
  if (~x & 1 << A_CR_DLB) r++;
  if (~x & 1 << A_CR_DBR) r++;
  return r;
}

// =========================================================================
   int  Pack_ct::pk()
// -------------------------------------------------------------------------
// twists of corners --> < 3^7, and even more for incomplete cubes
{
  int i, c = 0, l = 1;

  for (i = 0; i < n; i++)
    if (a[i]) {
      l *= 3;
      c = 3 * c + a[i] - 1;
    }
  if ((o & 0xFF) == 0) { // all orientations are set
    l /= 3; // then the last one is defined by the others
    c /= 3;
  }
  return comb_nk_pk() * l + c;
}

// =========================================================================
   void  Pack_ct::unpk(int c)
// -------------------------------------------------------------------------
{
  int i, t, l = 1;

  for (i = 0; i < n; i++) // count number of different orientations
    if (~o & 1 << i)
      l *= 3;
  if (o & 0xFF) { // some orientations are not set
    comb_nk_unpk(c / l); // unpack combination
    c %= l; // let it be only orientations
    for (i = n - 1; i >= 0; i--)
      if (a[i]) {
        a[i] = c % 3 + 1;
        c /= 3;
      }
  }
  else {  // all orientations are set
    t = 0;
    l /= 3; // one corner orientation is given
    comb_nk_unpk(c / l);
    c %= l;
    for (i = n - 2; i >= 0; i--) {
      a[i] = c % 3 + 1;
      t += c % 3;
      c /= 3;
    }
    a[n - 1] = (3 - (t % 3)) % 3 + 1; // set the last orientation
  }
}

// =========================================================================
   void  Pack_ct::adjust(int i0, int i1, int i2, int i3)
// -------------------------------------------------------------------------
// twists the given 2 corners clockwise and 2 counter-clockwise
{
  if (a[i0]) a[i0] = (a[i0] - 1 + 1) % 3 + 1; // clockwise
  if (a[i1]) a[i1] = (a[i1] - 1 + 2) % 3 + 1; // counter-clockwise
  if (a[i2]) a[i2] = (a[i2] - 1 + 1) % 3 + 1; // clockwise
  if (a[i3]) a[i3] = (a[i3] - 1 + 2) % 3 + 1; // counter-clockwise
}

// =========================================================================
   int  Pack_ct::len()
// -------------------------------------------------------------------------
{
  int i, l = 1;

  for (i = 0; i < n; i++)
    if (~o & 1 << i)
      l *= 3;
  if ((o & 0xFF) == 0) // all orientations are set
    l /= 3;
  return comb_nk() * l;
}

// =========================================================================
   int  Pack_ct::startlen()
// -------------------------------------------------------------------------
// returns the number of all solved positions, that can be obtained by start(x)
{
  int i, p1 = 0, o1 = 0;

  for (i = 0; i < n; i++)
    if (o >> 8 & 1 << i) {
      p1++;
      if (~o & 1 << i)
        o1++;
    }
  return _comb_nk(p1, o1);
}

// =========================================================================
   int  Pack_ct::start(int x)
// -------------------------------------------------------------------------
// by redefining of this (and previous) function can be realized
// solving to the specified state (eg. given by the user)
// x = 0, 1,..., startlen() - 1
{
  int i, j, p1 = 0, o1 = 0;

  for (i = 0; i < n; i++)
    if (o >> 8 & 1 << i) { // unspecified position
      p1++;
      if (~o & 1 << i)     // specified orientation
        o1++;
    }
  Comb c(p1, o1);
  c.comb_nk_unpk(x);
  for (i = 0, j = 0; i < n; i++)
    if (o >> 8 & 1 << i)  // unspecified position
      a[i] = c.a[j++];
    else if (~o & 1 << i) // specified position and orientation
      a[i] = 1;
    else                  // specified position, unspecified orientation
      a[i] = 0;
  return pk();
}

// =========================================================================
// EDGES' FLIPS
// =========================================================================
// all is nearly the same as for CT
// =========================================================================
   int  Pack_ef::act(int x)
// -------------------------------------------------------------------------
{
  int r = 0;

  if (~x & 1 << A_ED_UF) r++;
  if (~x & 1 << A_ED_UR) r++;
  if (~x & 1 << A_ED_UB) r++;
  if (~x & 1 << A_ED_UL) r++;
  if (~x & 1 << A_ED_DF) r++;
  if (~x & 1 << A_ED_DR) r++;
  if (~x & 1 << A_ED_DB) r++;
  if (~x & 1 << A_ED_DL) r++;
  if (~x & 1 << A_ED_FR) r++;
  if (~x & 1 << A_ED_FL) r++;
  if (~x & 1 << A_ED_BR) r++;
  if (~x & 1 << A_ED_BL) r++;
  return r;
}

// =========================================================================
   int  Pack_ef::pk()
// -------------------------------------------------------------------------
// flips of edges --> < 2^11 and even more for incomplete cubes
{
  int i, e = 0, l = 1;

  for (i = 0; i < n; i++)
    if (a[i]) {
      l *= 2;
      e = 2 * e + a[i] - 1;
    }
  if ((o & 0xFFF) == 0) {
    l /= 2;
    e /= 2;
  }
  return comb_nk_pk() * l + e;
}

// ========================================================================= 
   void  Pack_ef::unpk(int e)
// ------------------------------------------------------------------------- 
{
  int i, f, l = 1;

  for (i = 0; i < n; i++)
    if (~o & 1 << i)
      l *= 2;
  if (o & 0xFFF) {
    comb_nk_unpk(e / l);
    e %= l;
    for (i = n - 1; i >= 0; i--)
      if (a[i]) {
        a[i] = e % 2 + 1;
        e /= 2;
      }
  }
  else {
    f = 0;
    l /= 2;
    comb_nk_unpk(e / l);
    e %= l;
    for (i = n - 2; i >= 0; i--) {
      a[i] = e % 2 + 1;
      f += e % 2;
      e /= 2;
    }
    a[n - 1] = (2 - (f % 2)) % 2 + 1;
  }
}

// =========================================================================
   void  Pack_ef::adjust(int i0, int i1, int i2, int i3)
// -------------------------------------------------------------------------
{
  if (a[i0]) a[i0] = 1 - (a[i0] - 1) + 1;
  if (a[i1]) a[i1] = 1 - (a[i1] - 1) + 1;
  if (a[i2]) a[i2] = 1 - (a[i2] - 1) + 1;
  if (a[i3]) a[i3] = 1 - (a[i3] - 1) + 1;
}

// =========================================================================
   int  Pack_ef::len()
// -------------------------------------------------------------------------
{
  int i, l = 1;

  for (i = 0; i < n; i++)
    if (~o & 1 << i)
      l *= 2;
  if ((o & 0xFFF) == 0)
    l /= 2;
  return comb_nk() * l;
}

// =========================================================================
   int  Pack_ef::startlen()
// -------------------------------------------------------------------------
{
  int i, p1 = 0, o1 = 0;

  for (i = 0; i < n; i++)
    if (o >> 12 & 1 << i) {
      p1++;
      if (~o & 1 << i)
        o1++;
    }
  return _comb_nk(p1, o1);
}

// =========================================================================
   int  Pack_ef::start(int x)
// -------------------------------------------------------------------------
{
  int i, j, p1 = 0, o1 = 0;

  for (i = 0; i < n; i++)
    if (o >> 12 & 1 << i) {
      p1++;
      if (~o & 1 << i)
        o1++;
    }
  Comb c(p1, o1);
  c.comb_nk_unpk(x);
  for (i = 0, j = 0; i < n; i++)
    if (o >> 12 & 1 << i)
      a[i] = c.a[j++];
    else if (~o & 1 << i)
      a[i] = 1;
    else
      a[i] = 0;
  return pk();
}

// =========================================================================
// MIDDLE LAYER EDGES' LOCATIONS
// =========================================================================
   int  Pack_el::act(int x)
// -------------------------------------------------------------------------
{
  int r = 0;

  if (~x & 1 << A_ED_FR) r++;
  if (~x & 1 << A_ED_FL) r++;
  if (~x & 1 << A_ED_BR) r++;
  if (~x & 1 << A_ED_BL) r++;
  return r;
}

// =========================================================================
   int  Pack_el::pk()
// -------------------------------------------------------------------------
// placing of the 4 middle layer edge (unordered) --> < 12x11x10x9/4!
{
  return comb_nk_pk();
}

// =========================================================================
   void  Pack_el::unpk(int e)
// -------------------------------------------------------------------------
{
  comb_nk_unpk(e);
}

// =========================================================================
   int  Pack_el::len()
// -------------------------------------------------------------------------
{
  return comb_nk();
}

// =========================================================================
   int  Pack_el::startlen()
// -------------------------------------------------------------------------
{
  return _comb_nk(4, act(p));
}

// =========================================================================
   int  Pack_el::start(int x)
// -------------------------------------------------------------------------
{
  Comb c(4, act(p));

  c.comb_nk_unpk(x);
  clear();
  a[A_ED_FR] = c.a[0];
  a[A_ED_FL] = c.a[1];
  a[A_ED_BR] = c.a[2];
  a[A_ED_BL] = c.a[3];
  return pk();
}

// =========================================================================
// CORNERS' PERMUTATIONS
// =========================================================================
   int  Pack_cp::act(int x)
// -------------------------------------------------------------------------
{
  int r = 0;

  if (~x & 1 << A_CR_UFR) r++;
  if (~x & 1 << A_CR_URB) r++;
  if (~x & 1 << A_CR_UBL) r++;
  if (~x & 1 << A_CR_ULF) r++;
  if (~x & 1 << A_CR_DRF) r++;
  if (~x & 1 << A_CR_DFL) r++;
  if (~x & 1 << A_CR_DLB) r++;
  if (~x & 1 << A_CR_DBR) r++;
  return r;
}

// =========================================================================
   int  Pack_cp::pk()
// -------------------------------------------------------------------------
// permutation of the corners of the cube --> < 8!
{
  return var_nk_pk();
}

// =========================================================================
   void  Pack_cp::unpk(int c)
// -------------------------------------------------------------------------
{
  var_nk_unpk(c);
}

// =========================================================================
   int  Pack_cp::len()
// -------------------------------------------------------------------------
{
  return var_nk();
}

// =========================================================================
   int  Pack_cp::startlen()
// -------------------------------------------------------------------------
{
  return 1;
}

// =========================================================================
   int  Pack_cp::start(int x)
// -------------------------------------------------------------------------
{
  int r = 1;

  clear();
  if (~p & 1 << A_CR_UFR) a[B_CR_UFR] = r++;
  if (~p & 1 << A_CR_URB) a[B_CR_URB] = r++;
  if (~p & 1 << A_CR_UBL) a[B_CR_UBL] = r++;
  if (~p & 1 << A_CR_ULF) a[B_CR_ULF] = r++;
  if (~p & 1 << A_CR_DRF) a[B_CR_DRF] = r++;
  if (~p & 1 << A_CR_DFL) a[B_CR_DFL] = r++;
  if (~p & 1 << A_CR_DLB) a[B_CR_DLB] = r++;
  if (~p & 1 << A_CR_DBR) a[B_CR_DBR] = r++;
  return pk();
}

// =========================================================================
// UP AND DOWN EDGES' PERMUTATIONS
// =========================================================================
   int  Pack_ep::act(int x)
// -------------------------------------------------------------------------
{
  int r = 0;

  if (~x & 1 << A_ED_UF) r++;
  if (~x & 1 << A_ED_UR) r++;
  if (~x & 1 << A_ED_UB) r++;
  if (~x & 1 << A_ED_UL) r++;
  if (~x & 1 << A_ED_DF) r++;
  if (~x & 1 << A_ED_DR) r++;
  if (~x & 1 << A_ED_DB) r++;
  if (~x & 1 << A_ED_DL) r++;
  return r;
}

// =========================================================================
   int  Pack_ep::pk()
// -------------------------------------------------------------------------
// permutation of up and down edges of the cube --> < 8!
{
  return var_nk_pk();
}

// =========================================================================
   void  Pack_ep::unpk(int e)
// -------------------------------------------------------------------------
{
  var_nk_unpk(e);
}

// =========================================================================
   int  Pack_ep::len()
// -------------------------------------------------------------------------
{
  return var_nk();
}

// =========================================================================
   int  Pack_ep::startlen()
// -------------------------------------------------------------------------
{
  return 1;
}

// =========================================================================
   int  Pack_ep::start(int x)
// -------------------------------------------------------------------------
{
  int r = 1;

  clear();
  if (~p & 1 << A_ED_UF) a[B_ED_UF] = r++;
  if (~p & 1 << A_ED_UR) a[B_ED_UR] = r++;
  if (~p & 1 << A_ED_UB) a[B_ED_UB] = r++;
  if (~p & 1 << A_ED_UL) a[B_ED_UL] = r++;
  if (~p & 1 << A_ED_DF) a[B_ED_DF] = r++;
  if (~p & 1 << A_ED_DR) a[B_ED_DR] = r++;
  if (~p & 1 << A_ED_DB) a[B_ED_DB] = r++;
  if (~p & 1 << A_ED_DL) a[B_ED_DL] = r++;
  return pk();
}

// =========================================================================
// MIDDLE EDGES' PERMUTATIONS
// =========================================================================
   int  Pack_mp::act(int x)
// -------------------------------------------------------------------------
{
  int r = 0;

  if (~x & 1 << A_ED_FR) r++;
  if (~x & 1 << A_ED_FL) r++;
  if (~x & 1 << A_ED_BR) r++;
  if (~x & 1 << A_ED_BL) r++;
  return r;
}

// =========================================================================
   int  Pack_mp::pk()
// -------------------------------------------------------------------------
// permutation of middle layer edges of the cube --> < 4!
{
  return var_nk_pk();
}

// =========================================================================
   void  Pack_mp::unpk(int m)
// -------------------------------------------------------------------------
{
  var_nk_unpk(m);
}

// =========================================================================
   int  Pack_mp::len()
// -------------------------------------------------------------------------
{
  return var_nk();
}

// =========================================================================
   int  Pack_mp::startlen()
// -------------------------------------------------------------------------
{
  return 1;
}

// =========================================================================
   int  Pack_mp::start(int x)
// -------------------------------------------------------------------------
{
  int r = 1;

  clear();
  if (~p & 1 << A_ED_FR) a[B_MD_FR] = r++;
  if (~p & 1 << A_ED_FL) a[B_MD_FL] = r++;
  if (~p & 1 << A_ED_BR) a[B_MD_BR] = r++;
  if (~p & 1 << A_ED_BL) a[B_MD_BL] = r++;
  return pk();
}

// =========================================================================
// UP SLICE EDGES' PERMUTATIONS
// =========================================================================
   int  Pack_use::act(int x)
// -------------------------------------------------------------------------
{
  int r = 0;

  if (~x & 1 << A_ED_UF) r++;
  if (~x & 1 << A_ED_UR) r++;
  if (~x & 1 << A_ED_UB) r++;
  if (~x & 1 << A_ED_UL) r++;
  return r;
}

// =========================================================================
   int  Pack_use::pk()
// -------------------------------------------------------------------------
// placing of the 4 edges of the cube --> < 12x11x10x9
{
  return var_nk_pk();
}

// =========================================================================
   void  Pack_use::unpk(int s)
// -------------------------------------------------------------------------
{
  var_nk_unpk(s);
}

// =========================================================================
   int  Pack_use::len()
// -------------------------------------------------------------------------
{
  return var_nk();
}

// =========================================================================
   int  Pack_use::startlen()
// -------------------------------------------------------------------------
{
  return 1;
}

// =========================================================================
   int  Pack_use::start(int x)
// -------------------------------------------------------------------------
{
  int r = 1;

  clear();
  if (~p & 1 << A_ED_UF) a[A_ED_UF] = r++;
  if (~p & 1 << A_ED_UR) a[A_ED_UR] = r++;
  if (~p & 1 << A_ED_UB) a[A_ED_UB] = r++;
  if (~p & 1 << A_ED_UL) a[A_ED_UL] = r++;
  return pk();
}

// =========================================================================
   int  Pack_use::to_uhe(int s)
// -------------------------------------------------------------------------
// converts the placing of the 4 up edges on any positions to
// the placing of theese 4 edges on up and down layer
{
  Comb c(8, act(p));

  var_nk_unpk(s);
  c.a[B_ED_UF] = a[A_ED_UF];
  c.a[B_ED_UR] = a[A_ED_UR];
  c.a[B_ED_UB] = a[A_ED_UB];
  c.a[B_ED_UL] = a[A_ED_UL];
  c.a[B_ED_DF] = a[A_ED_DF];
  c.a[B_ED_DR] = a[A_ED_DR];
  c.a[B_ED_DB] = a[A_ED_DB];
  c.a[B_ED_DL] = a[A_ED_DL];
  return c.var_nk_pk();
}

// =========================================================================
   int  Pack_use::is_p2(int s)
// -------------------------------------------------------------------------
{
  unpk(s);

  if (a[A_ED_FR] || a[A_ED_FL] || a[A_ED_BR] || a[A_ED_BL])
    return 0;
  return 1;
}

// =========================================================================
// DOWN SLICE EDGES' PERMUTATIONS
// =========================================================================
// the same as USE but for bottom layer
// =========================================================================
   int  Pack_dse::act(int x)
// -------------------------------------------------------------------------
{
  int r = 0;

  if (~x & 1 << A_ED_DF) r++;
  if (~x & 1 << A_ED_DR) r++;
  if (~x & 1 << A_ED_DB) r++;
  if (~x & 1 << A_ED_DL) r++;
  return r;
}

// =========================================================================
   int  Pack_dse::pk()
// -------------------------------------------------------------------------
{
  return var_nk_pk();
}

// =========================================================================
   void  Pack_dse::unpk(int s)
// -------------------------------------------------------------------------
{
  var_nk_unpk(s);
}

// =========================================================================
   int  Pack_dse::len()
// -------------------------------------------------------------------------
{
  return var_nk();
}

// =========================================================================
   int  Pack_dse::startlen()
// -------------------------------------------------------------------------
{
  return 1;
}

// =========================================================================
   int  Pack_dse::start(int x)
// -------------------------------------------------------------------------
{
  int r = 1;

  clear();
  if (~p & 1 << A_ED_DF) a[A_ED_DF] = r++;
  if (~p & 1 << A_ED_DR) a[A_ED_DR] = r++;
  if (~p & 1 << A_ED_DB) a[A_ED_DB] = r++;
  if (~p & 1 << A_ED_DL) a[A_ED_DL] = r++;
  return pk();
}

// =========================================================================
   int  Pack_dse::to_dhe(int s)
// -------------------------------------------------------------------------
{
  Comb c(8, act(p));

  var_nk_unpk(s);
  c.a[B_ED_UF] = a[A_ED_UF];
  c.a[B_ED_UR] = a[A_ED_UR];
  c.a[B_ED_UB] = a[A_ED_UB];
  c.a[B_ED_UL] = a[A_ED_UL];
  c.a[B_ED_DF] = a[A_ED_DF];
  c.a[B_ED_DR] = a[A_ED_DR];
  c.a[B_ED_DB] = a[A_ED_DB];
  c.a[B_ED_DL] = a[A_ED_DL];
  return c.var_nk_pk();
}

// =========================================================================
   int  Pack_dse::is_p2(int s)
// -------------------------------------------------------------------------
{
  unpk(s);

  if (a[A_ED_FR] || a[A_ED_FL] || a[A_ED_BR] || a[A_ED_BL])
    return 0;
  return 1;
}

// =========================================================================
// MIDDLE SLICE EDGES' PERMUTATIONS
// =========================================================================
// the same as USE and DSE but for middle layer
// =========================================================================
   int  Pack_mse::act(int x)
// -------------------------------------------------------------------------
{
  int r = 0;

  if (~x & 1 << A_ED_FR) r++;
  if (~x & 1 << A_ED_FL) r++;
  if (~x & 1 << A_ED_BR) r++;
  if (~x & 1 << A_ED_BL) r++;
  return r;
}

// =========================================================================
   int  Pack_mse::pk()
// -------------------------------------------------------------------------
{
  return var_nk_pk();
}

// =========================================================================
   void  Pack_mse::unpk(int s)
// -------------------------------------------------------------------------
{
  var_nk_unpk(s);
}

// =========================================================================
   int  Pack_mse::len()
// -------------------------------------------------------------------------
{
  return var_nk();
}

// =========================================================================
   int  Pack_mse::startlen()
// -------------------------------------------------------------------------
{
  return 1;
}

// =========================================================================
   int  Pack_mse::start(int x)
// -------------------------------------------------------------------------
{
  int r = 1;

  clear();
  if (~p & 1 << A_ED_FR) a[A_ED_FR] = r++;
  if (~p & 1 << A_ED_FL) a[A_ED_FL] = r++;
  if (~p & 1 << A_ED_BR) a[A_ED_BR] = r++;
  if (~p & 1 << A_ED_BL) a[A_ED_BL] = r++;
  return pk();
}

// =========================================================================
   int  Pack_mse::to_mp(int s)
// -------------------------------------------------------------------------
{
  Comb c(4, act(p));

  var_nk_unpk(s);
  c.a[B_MD_FR] = a[A_ED_FR];
  c.a[B_MD_FL] = a[A_ED_FL];
  c.a[B_MD_BR] = a[A_ED_BR];
  c.a[B_MD_BL] = a[A_ED_BL];
  return c.var_nk_pk();
}

// =========================================================================
// UP EDGES' PERMUTATIONS ON DOWN AND UP POSITIONS
// =========================================================================
   int  Pack_uhe::act(int x)
// -------------------------------------------------------------------------
{
  int r = 0;

  if (~x & 1 << A_ED_UF) r++;
  if (~x & 1 << A_ED_UR) r++;
  if (~x & 1 << A_ED_UB) r++;
  if (~x & 1 << A_ED_UL) r++;
  return r;
}

// =========================================================================
   int  Pack_uhe::pk()
// -------------------------------------------------------------------------
// placing of the up edges on up and down layers --> < 4!
{
  return var_nk_pk();
}

// =========================================================================
   void  Pack_uhe::unpk(int h)
// -------------------------------------------------------------------------
{
  var_nk_unpk(h);
}

// =========================================================================
   int  Pack_uhe::len()
// -------------------------------------------------------------------------
{
  return var_nk();
}

// =========================================================================
   int  Pack_uhe::startlen()
// -------------------------------------------------------------------------
{
  return 1;
}

// =========================================================================
   int  Pack_uhe::start(int x)
// -------------------------------------------------------------------------
{
  int r = 1;

  clear();
  if (~p & 1 << A_ED_UF) a[B_ED_UF] = r++;
  if (~p & 1 << A_ED_UR) a[B_ED_UR] = r++;
  if (~p & 1 << A_ED_UB) a[B_ED_UB] = r++;
  if (~p & 1 << A_ED_UL) a[B_ED_UL] = r++;
  return pk();
}

// =========================================================================
   int  Pack_uhe::to_ep(int uh, int dh)
// -------------------------------------------------------------------------
{
  int i, m = 0;
  Pack_dhe pd(p);
  Pack_ep pe(p);

  unpk(uh);
  for (i = 0; i < 8; i++) {
    pe.a[i] = a[i];
    if (m < a[i])
      m = a[i];
  }
  pd.unpk(dh);
  for (i = 0; i < 8; i++)
    if (pd.a[i])
      pe.a[i] = pd.a[i] + m;
  return pe.pk();
}

// =========================================================================
// DOWN EDGES' PERMUTATIONS ON DOWN AND UP POSITIONS
// =========================================================================
   int  Pack_dhe::act(int x)
// -------------------------------------------------------------------------
{
  int r = 0;

  if (~x & 1 << A_ED_DF) r++;
  if (~x & 1 << A_ED_DR) r++;
  if (~x & 1 << A_ED_DB) r++;
  if (~x & 1 << A_ED_DL) r++;
  return r;
}

// =========================================================================
   int  Pack_dhe::pk()
// -------------------------------------------------------------------------
{
  return var_nk_pk();
}

// =========================================================================
   void  Pack_dhe::unpk(int h)
// -------------------------------------------------------------------------
{
  var_nk_unpk(h);
}

// =========================================================================
   int  Pack_dhe::len()
// -------------------------------------------------------------------------
{
  return var_nk();
}

// =========================================================================
   int  Pack_dhe::startlen()
// -------------------------------------------------------------------------
{
  return 1;
}

// =========================================================================
   int  Pack_dhe::start(int x)
// -------------------------------------------------------------------------
{
  int r = 1;

  clear();
  if (~p & 1 << A_ED_DF) a[B_ED_DF] = r++;
  if (~p & 1 << A_ED_DR) a[B_ED_DR] = r++;
  if (~p & 1 << A_ED_DB) a[B_ED_DB] = r++;
  if (~p & 1 << A_ED_DL) a[B_ED_DL] = r++;
  return pk();
}

/*
// =========================================================================
   int  Pack_dhe::to_ep(int dh, int uh)
// -------------------------------------------------------------------------
{
  Pack_dhe pu(p);
  Pack_ep pe(p);
  int m = 0;

  pu.unpk(uh);
  for (int i = 0; i < 8; i++) {
    pe.a[i] = pu.a[i];
    if (m < pu.a[i])
      m = pu.a[i];
  }
  unpk(dh);
  for (int i = 0; i < 8; i++)
    if (a[i])
      pe.a[i] = a[i] + m;
  return pe.pk();
}
*/

